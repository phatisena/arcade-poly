{"entries":[{"timestamp":1743353772751,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":12114,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":210,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1743354295287,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":498,"length1":54,"diffs":[[1,"        px: number\n        py: number\n        pz: number\n"]]},{"start1":588,"length1":40,"diffs":[[1,"        mx: number\n        my: number\n        mz: number\n"]]},{"start1":980,"length1":148,"diffs":[[1,"        return [ct,cv]\n"]]},{"start1":1084,"length1":60,"diffs":[[1,"    export function render(image: Image) {\n"]]}]}]},{"timestamp":1743354734738,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":313,"length1":88,"diffs":[[1,""]]},{"start1":654,"length1":13,"diffs":[[1,""]]},{"start1":928,"length1":32,"diffs":[[1,""]]},{"start1":960,"length1":31,"diffs":[[1,"        let umesh: [ct,cv]\n        umesh[0].indices = [0,0,0]\n        umesh[0].color = 0\n        umesh[1] = {x: 0, y: 0, z: 0}\n"]]},{"start1":1115,"length1":64,"diffs":[[1,""]]}]}]},{"timestamp":1743355333955,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":336,"length1":24,"diffs":[[1,"    //% block=\"vector\"\n"]]},{"start1":367,"length1":25,"diffs":[[1,"    //% block=\"texture\"\n"]]},{"start1":742,"length1":70,"diffs":[[1,"    export \n"]]},{"start1":1093,"length1":24,"diffs":[[1,"        let umesh: [ct[],cv[]]\n"]]},{"start1":1152,"length1":215,"diffs":[[1,"    //% block\n    export function getmesh(mymesh: [ct[],cv[]])\n"]]},{"start1":1290,"length1":57,"diffs":[[1,"    export function render(mypoly: [ct,cv], image: Image) {\n"]]},{"start1":1783,"length1":106,"diffs":[[1,"            let vertices = cv;\n            let triangles = ct;\n            ct = [\n"]]},{"start1":1929,"length1":27,"diffs":[[1,"            cv = [\n"]]}]}]},{"timestamp":1743355882917,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":970,"length1":0,"diffs":[[1,"    let ct = [\n        { indices: [0, 0, 0], color: 13 }\n    ];\n    let cv = [\n        { x: 0, y: 0, z: 0 },\n"]]},{"start1":1080,"length1":0,"diffs":[[1,"\n    ];\n\n"]]},{"start1":1205,"length1":38,"diffs":[[1,"    //% block=\"get $mymesh as $t\"\n"]]},{"start1":1294,"length1":102,"diffs":[[1,"    export function getmesh(mymesh: mesh, t: MeshType) {\n        if (t > 0) return mymesh.cvs\n"]]},{"start1":1421,"length1":97,"diffs":[[1,"    //% block=\"render to $image\"\n"]]},{"start1":10124,"length1":163,"diffs":[[1,"    //% block=\"add vertice x $x y $y z $z\" \n    export function addvertice(x: number, y: number, z: number) {\n        function formatvertice(x: number, y: number, z: number) {\n            return {\n                x, y, z,\n            };\n        }\n        let formattedData = formatvertice(x, y, z,);\n        cv.push(formattedData);\n"]]},{"start1":10463,"length1":221,"diffs":[[1,"    //% block=\"add triangle indice 1 $one indice 2 $two indice 3 $three color $col\"\n    export function addtriangle(one: number, two: number, three: number, col: number) {\n        function formatTriangle(x: number, y: number, z: number, color: number) {\n            return {\n                indices: [x, y, z,], color: color\n            };\n"]]},{"start1":10813,"length1":0,"diffs":[[1,"        let formattedData2 = formatTriangle(one, two, three, col);\n        ct.push(formattedData2)\n"]]}]}]},{"timestamp":1743356457554,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":73,"diffs":[[1,"//% color=\"#279139\" icon=\"\\uf1b2\"\nnamespace polybox {\n"]]},{"start1":952,"length1":0,"diffs":[[1,"\n"]]},{"start1":971,"length1":29,"diffs":[[1,""]]},{"start1":1087,"length1":29,"diffs":[[1,""]]},{"start1":1315,"length1":32,"diffs":[[1,""]]},{"start1":10082,"length1":32,"diffs":[[1,""]]},{"start1":10252,"length1":33,"diffs":[[1,""]]},{"start1":10490,"length1":34,"diffs":[[1,""]]},{"start1":10776,"length1":35,"diffs":[[1,""]]},{"start1":11054,"length1":31,"diffs":[[1,""]]},{"start1":11336,"length1":26,"diffs":[[1,""]]},{"start1":11438,"length1":30,"diffs":[[1,""]]},{"start1":11704,"length1":29,"diffs":[[1,""]]},{"start1":11789,"length1":29,"diffs":[[1,""]]},{"start1":11874,"length1":29,"diffs":[[1,""]]},{"start1":11960,"length1":32,"diffs":[[1,""]]}]}]},{"timestamp":1743357056310,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":210,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1743353772750,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-poly\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1743355572842,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n//% color=\"#279139\" icon=\"\\uf1b2\"\nnamespace polybox {\n\nexport enum Angles {\n    //% block=\"angle x\"\n    Angle_X,\n    //% block=\"angle y\"\n    Angle_Y,\n    //% block=\"angle z\"\n    Angle_Z,\n}\nexport enum Cameras {\n    //% block=\"cam x\"\n    Cam_x,\n    //% block=\"cam y\"\n    Cam_y,\n    //% block=\"cam z\"\n    Cam_z,\n}\nexport enum MeshType {\n    //% block=\"vector\"\n    cv,\n    //% block=\"texture\"\n    ct,\n}\nexport enum SortingMethods {\n    //% block=\"accurate\"\n    Accurate,\n    //% block=\"fast\"\n    Fast,\n    //% block=\"fast and accurate\"\n    Fast_and_Accurate,\n}\n\n    export interface cv {\n        x: number\n        y: number\n        z: number\n    }\n\n    export interface ct {\n        indices: [number,number,number]\n        color: number\n    }\n\n    export interface mesh {\n        cts: ct[]\n        cvs: cv[]\n    }\n\n    let axchange = 0\n    let azchange = 0\n    let camx = 0\n    let camy = 0\n    let camz = 0\n    let sizechange = 0\n    let aychange = 0\n\n    let sort = 2\n    let ct = [\n        { indices: [0, 0, 0], color: 13 }\n    ];\n    let cv = [\n        { x: 0, y: 0, z: 0 },\n\n\n    ];\n\n    //% block=\"create new mesh\"\n    export function newmesh() {\n        let umesh: mesh\n        return umesh\n    }\n\n    //% block=\"\"\n    export function getmesh(mymesh: mesh, t: MeshType) {\n        if (t > 0) return mymesh.cvs\n        return mymesh.cts\n    }\n\n    //% block=\"render to $image\"\n    //% image.shadow=screen_image_picker\n    export function render(mypoly: [ct,cv], image: Image) {\n        function updateCube() {\n            let bg = image;\n            let bgsave = bg.clone()\n            let angleX = 0;\n            angleX += axchange\n            let angleY = 0;\n            let angleZ = 0;\n            angleY += aychange\n            angleZ += azchange\n            let centerX = scene.screenWidth() / 2;\n            let centerY = scene.screenHeight() / 2;\n            let size = 1\n            size += sizechange\n\n            let vertices = cv;\n            let triangles = ct;\n            ct = [\n                { indices: [0, 0, 0], color: 0 }\n            ];\n            cv = [\n                { x: 0, y: 0, z: 0 },\n            ];\n            let zerosArray: number[] = [];\n            for (let i = 0; i < vertices.length; i++) {\n                zerosArray.push(0);\n            }\n            let cosX = Math.cos(angleX);\n            let sinX = Math.sin(angleX);\n            let cosY = Math.cos(angleY);\n            let sinY = Math.sin(angleY);\n            let cosZ = Math.cos(angleZ);\n            let sinZ = Math.sin(angleZ);\n\n            let rotatedVertices = vertices.map((vertex, index) => {\n                let x = vertex.x;\n                let y = vertex.y;\n                let z = vertex.z;\n                if (!(index > 5 && index < 9)) {\n                    x -= camx\n                    y -= camy\n                    z -= camz\n                }\n                // rotate y\n                let cosY = Math.cos(angleY);\n                let sinY = Math.sin(angleY);\n                let rotatedX = x * cosY + z * sinY;\n                let rotatedZ = -x * sinY + z * cosY;\n\n                // Rotate x\n                let cosX = Math.cos(angleX);\n                let sinX = Math.sin(angleX);\n                let rotatedZ2 = rotatedZ * cosX - y * sinX;\n                let rotatedY2 = rotatedZ * sinX + y * cosX;\n\n                // Rotate z\n                let cosZ = Math.cos(angleZ);\n                let sinZ = Math.sin(angleZ);\n                let rotatedX2 = rotatedX * cosZ - rotatedY2 * sinZ;\n                let rotatedY3 = rotatedX * sinZ + rotatedY2 * cosZ;\n\n                // perspective\n                let scaleFactor = 150 / (150 + rotatedZ2);\n                let projectedX = rotatedX2 * scaleFactor;\n                let projectedY = rotatedY2 * scaleFactor;\n\n                // screen coordinates\n                let screenX = centerX + projectedX;\n                let screenY = centerY + projectedY;\n\n                if (rotatedZ2 > -100) {\n\n                } else {\n                    zerosArray[index] = 1\n                }\n                return { x: screenX, y: screenY, z: rotatedZ2 };\n            });\n\n            function quicksort(arr: any[], low: number, high: number, rotatedVertices: any[]) {\n                if (low < high) {\n                    let pivotIndex = choosePivot(arr, low, high, rotatedVertices);\n                    let partitionIndex = partition(arr, low, high, rotatedVertices, pivotIndex);\n\n                    quicksort(arr, low, partitionIndex - 1, rotatedVertices);\n                    quicksort(arr, partitionIndex + 1, high, rotatedVertices);\n                }\n            }\n\n            function choosePivot(arr: any[], low: number, high: number, rotatedVertices: any[]): number {\n                // Choose the median of three values: low, middle, high\n                let middle = Math.floor((low + high) / 2);\n\n                if (averageZ(rotatedVertices, arr[low].indices) > averageZ(rotatedVertices, arr[middle].indices)) {\n                    [arr[low], arr[middle]] = [arr[middle], arr[low]];\n                }\n                if (averageZ(rotatedVertices, arr[low].indices) > averageZ(rotatedVertices, arr[high].indices)) {\n                    [arr[low], arr[high]] = [arr[high], arr[low]];\n                }\n                if (averageZ(rotatedVertices, arr[middle].indices) > averageZ(rotatedVertices, arr[high].indices)) {\n                    [arr[middle], arr[high]] = [arr[high], arr[middle]];\n                }\n\n                return middle;\n            }\n\n            function partition(arr: any[], low: number, high: number, rotatedVertices: any[], pivotIndex: number): number {\n                let pivotValue = averageZ(rotatedVertices, arr[pivotIndex].indices);\n                let i = low - 1;\n\n                for (let j = low; j <= high; j++) {\n                    let currentAverageZ = averageZ(rotatedVertices, arr[j].indices);\n                    if (currentAverageZ > pivotValue) {\n                        i++;\n                        [arr[i], arr[j]] = [arr[j], arr[i]];\n                    }\n                }\n\n                [arr[i + 1], arr[pivotIndex]] = [arr[pivotIndex], arr[i + 1]];\n                return i + 1;\n            }\n\n            function averageZ(rotatedVertices: any[], indices: number[]): number {\n                return (rotatedVertices[indices[0]].z + rotatedVertices[indices[1]].z + rotatedVertices[indices[2]].z) / 3;\n            }\n\n            function quicksort2(triangles: any[], low: number, high: number, rotatedVertices: any[]) {\n                while (low < high) {\n                    let pi = partition2(triangles, low, high, rotatedVertices);\n\n                    // Optimize the recursion by tail call optimization\n                    if (pi - low < high - pi) {\n                        quicksort2(triangles, low, pi - 1, rotatedVertices);\n                        low = pi + 1;\n                    } else {\n                        quicksort2(triangles, pi + 1, high, rotatedVertices);\n                        high = pi - 1;\n                    }\n                }\n            }\n\n            function partition2(triangles: any[], low: number, high: number, rotatedVertices: any[]) {\n                let pivot = calculateAverageZ2(triangles[high], rotatedVertices);\n                let i = low;\n\n                for (let j = low; j < high; j++) {\n                    if (calculateAverageZ2(triangles[j], rotatedVertices) > pivot) {\n                        // Swap triangles[i] and triangles[j]\n                        let temp = triangles[i];\n                        triangles[i] = triangles[j];\n                        triangles[j] = temp;\n                        i++;\n                    }\n                }\n\n                // Swap triangles[i] and triangles[high]\n                let temp = triangles[i];\n                triangles[i] = triangles[high];\n                triangles[high] = temp;\n\n                return i;\n            }\n\n            function calculateAverageZ2(triangle: { indices: number[] }, rotatedVertices: { z: number }[]) {\n                let z = (rotatedVertices[triangle.indices[0]].z + rotatedVertices[triangle.indices[1]].z + rotatedVertices[triangle.indices[2]].z) / 3;\n                return z;\n            }\n\n\n\n\n            if (sort === 0) {\n                triangles.sort((b, a) => {\n                    let zA = (rotatedVertices[a.indices[0]].z + rotatedVertices[a.indices[1]].z + rotatedVertices[a.indices[2]].z) / 3;\n                    let zB = (rotatedVertices[b.indices[0]].z + rotatedVertices[b.indices[1]].z + rotatedVertices[b.indices[2]].z) / 3;\n                    return zA - zB;\n                });\n            } else if (sort === 1) {\n                quicksort(triangles, 0, triangles.length - 1, rotatedVertices);\n\n            } else if (sort === 2) {\n                quicksort2(triangles, 0, triangles.length - 1, rotatedVertices);\n\n            }\n\n\n\n            for (let i = 0; i < triangles.length; i++) {\n                let triangle = triangles[i];\n                let indices = triangle.indices;\n                let color = triangle.color;\n                if (!(zerosArray[indices[0]] === 1)) {\n                    if (!(zerosArray[indices[1]] === 1)) {\n                        if (!(zerosArray[indices[2]] === 1)) {\n                            helpers.imageFillTriangle(bg, rotatedVertices[indices[0]].x, rotatedVertices[indices[0]].y, rotatedVertices[indices[1]].x, rotatedVertices[indices[1]].y, rotatedVertices[indices[2]].x, rotatedVertices[indices[2]].y, color)\n\n                        }\n                    }\n                }\n                //scene.backgroundImage().fillTriangle(rotatedVertices[indices[0]].x, rotatedVertices[indices[0]].y, rotatedVertices[indices[1]].x, rotatedVertices[indices[1]].y, rotatedVertices[indices[2]].x, rotatedVertices[indices[2]].y, color);\n            }\n            rotatedVertices.length = 0;\n            triangles.length = 0;\n\n            console.log(zerosArray)\n\n        }\n        updateCube()\n\n\n    }\n\n    //% block=\"add vertice x $x y $y z $z\" \n    export function addvertice(x: number, y: number, z: number) {\n        function formatvertice(x: number, y: number, z: number) {\n            return {\n                x, y, z,\n            };\n        }\n        let formattedData = formatvertice(x, y, z,);\n        cv.push(formattedData);\n    }\n\n    //% block=\"add triangle indice 1 $one indice 2 $two indice 3 $three color $col\"\n    export function addtriangle(one: number, two: number, three: number, col: number) {\n        function formatTriangle(x: number, y: number, z: number, color: number) {\n            return {\n                indices: [x, y, z,], color: color\n            };\n        }\n        let formattedData2 = formatTriangle(one, two, three, col);\n        ct.push(formattedData2)\n    }\n\n    //% block=\"change $choice by $x\"\n    export function change(choice: Angles, x: number) {\n        if (choice === 0) {\n            axchange += x\n\n        } else if (choice === 1) {\n            aychange += x\n        } else if (choice === 2) {\n            azchange += x\n        }\n    }\n    //% block=\"change $choice by $x\"\n    export function changecam(choice: Cameras, x: number) {\n        if (choice === 0) {\n            camx += x\n\n        } else if (choice === 1) {\n            camy += x\n        } else if (choice === 2) {\n            camz += x\n        }\n    }\n    //% block=\"set $choice to $x\"\n    export function setangle(choice: Angles, x: number) {\n        if (choice === 0) {\n            axchange = x\n\n        } else if (choice === 1) {\n            aychange = x\n        } else if (choice === 2) {\n            azchange = x\n        }\n    }\n    //% block=\"set size to $x\"\n    export function setsize(x: number) {\n        sizechange = x\n    }\n\n    //% block=\"set sorting method to $method\"\n    export function sortingmethod(method: SortingMethods) {\n        if (method === 0) {\n            sort = 0\n        } else if (method === 1) {\n            sort = 1\n        } else {\n            sort = 2\n        }\n    }\n\n    //% block=\"angle x\"\n    export function anglex() {\n        return axchange\n    }\n    //% block=\"angle y\"\n    export function angley() {\n        return aychange\n    }\n    //% block=\"angle z\"\n    export function anglez() {\n        return azchange\n    }\n\n    //% block=\"set camera position to x: $x y: $y z: $z\"\n    export function setcampos(x: number, y: number, z: number) {\n        camx = x\n        camy = y\n        camz = z\n    }\n\n}\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-poly\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1743357170710}